-- 1757. Recyclable and Low Fat Products
SELECT product_id FROM Products
WHERE low_fats = 'Y' AND recyclable = 'Y'ï¼›

-- 584. Find Customer Referee
SELECT name FROM Customer
WHERE referee_id <> 2 OR referee_id IS NULL

-- 595. Big Countries
SELECT name, population, area 
FROM world
WHERE area >= 3000000 OR population >= 25000000

-- 1148. Article Views 1
SELECT DISTINCT author_id AS id
FROM views
WHERE author_id = viewer_id
ORDER BY id ASC

-- 1683. Invalid Tweets
SELECT tweet_id 
FROM tweets
WHERE LENGTH(content) > 15

-- 1378. Replace Employee ID With The Unique Identifier
SELECT eu.unique_id, e.name
FROM Employees e
LEFT JOIN EmployeeUNI eu
ON e.id = eu.id

-- 1068. Product Sales Analysis 1
SELECT p.product_name, s.year, s.price
FROM sales s
LEFT JOIN product p
ON s.product_id = p.product_id

-- 1581. Customer Who Visited but Did Not Make Any Transactions
SELECT v.customer_id, COUNT(v.customer_id) as count_no_trans
FROM Visits v
LEFT JOIN Transactions t
ON v.visit_id = t.visit_id
WHERE t.transaction_id IS NULL
GROUP BY v.customer_id

-- 197. Rising Temperature
SELECT w2.id
FROM weather w1 
JOIN weather w2 
ON DATEDIFF(w1.recordDate, w2.recordDate) = -1 AND w2.temperature > w1.temperature

-- 1661. Average Time of Process per Machine
SELECT a1.machine_id, ROUND(AVG(a2.timestamp - a1.timestamp),3) as processing_time
FROM activity a1
LEFT JOIN activity a2
ON a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id
WHERE a1.activity_type = 'start' AND a2.activity_type = 'end'
GROUP BY a1.machine_id

-- 577. Employee Bonus
SELECT e.name, b.bonus
FROM employee e
LEFT JOIN bonus b
ON e.empId = b.empID
WHERE COALESCE(bonus, 0 ) < 1000
 
# alternative: WHERE bonus < 1000 or bonus IS NULL

-- 1280. Students and Examinations
SELECT data.student_id, data.student_name, data.subject_name, COALESCE(subject.attended_exams,0) as attended_exams
FROM 
(SELECT student_id, subject_name, COUNT(subject_name) as attended_exams
FROM examinations
GROUP BY student_id, subject_name) as subject

RIGHT JOIN (
    SELECT *
    FROM students
    CROSS JOIN subjects
) as data
ON data.student_id = subject.student_id and data.subject_name = subject.subject_name
ORDER BY data.student_id, data.subject_name

-- 570. Managers with at Least 5 Direct Reports
SELECT b.id
FROM employee a
JOIN employee b
ON a.managerId = b.id
GROUP BY b.id, b.name
HAVING count(a.id)>5

-- 1934. Confirmation Rate
#Solution 1
SELECT s.user_id, ROUND(COALESCE(SUM(CASE WHEN c.action = 'confirmed' THEN c.cnt ELSE 0 END) * 1/SUM(c.cnt),0),2) AS confirmation_rate
FROM signups s
LEFT JOIN 
(SELECT user_id, action, COUNT(action) AS cnt
FROM confirmations
GROUP BY user_id, action) AS c
ON s.user_id = c.user_id
GROUP BY s.user_id

#Solution 2
SELECT s.user_id, ROUND(AVG(CASE WHEN c.action = 'confirmed' THEN 1 ELSE 0 END),2) as confirmation_rate
FROM signups s
LEFT JOIN confirmations c
ON s.user_id = c.user_id
GROUP BY s.user_id

-- 620. Not Boring Movies
SELECT * 
FROM cinema
WHERE description NOT LIKE 'boring' AND id % 2 <> 0
ORDER BY rating DESC

-- 1251. Average Selling Price
SELECT p.product_id, COALESCE(ROUND(SUM(p.price * u.units) /SUM(units),2),0) AS average_price
FROM prices p
LEFT JOIN UnitsSold u
ON p.product_id = u.product_id AND u.purchase_date BETWEEN p.start_date AND p.end_date
GROUP BY p.product_id

-- 1075. Project Employees I
SELECT p.project_id, ROUND(AVG(e.experience_years),2) AS average_years
FROM project p
LEFT JOIN employee e
ON p.employee_id = e.employee_id
GROUP BY p.project_id

-- 1633. Percentage of Users Attended a Contest
SELECT 
contest_id, 
round(
    (count(user_id)
    /
    (SELECT COUNT(DISTINCT user_id) FROM users))
    *100,2) as percentage
FROM register
GROUP BY contest_id
ORDER BY percentage DESC, contest_id ASC

-- 1211. Queries Quality and Percentage
SELECT 
query_name, 
ROUND(AVG(rating/position),2) AS quality,
##ROUND(SUM(rating < 3) / COUNT(rating) * 100,2) AS poor_query_percentage
##ROUND(SUM(CASE WHEN rating < 3 THEN 1 ELSE 0 END)/COUNT(rating) * 100,2) AS poor_query_percentage
ROUND(SUM(IF(rating<3,1,0))/COUNT(rating) *100,2) AS poor_query_percentage
FROM queries
GROUP BY query_name

-- 1193. Monthly Transactions I
SELECT 
DATE_FORMAT(trans_date, '%Y-%m') AS month, 
country, 
COUNT('id') AS trans_count, 
SUM(IF(state = 'approved',1,0)) AS approved_count, 
SUM(amount) AS trans_total_amount, 
sum(IF(state = 'approved',amount,0)) AS approved_total_amount
FROM transactions
GROUP BY month,country

-- 1174. Immediate Food Delivery II
WITH first_order AS (
    SELECT customer_id, MIN(order_date) as order_date
    FROM delivery
    GROUP BY customer_id  
)

SELECT ROUND(AVG(d.order_date = d.customer_pref_delivery_date)*100,2) as immediate_percentage 
FROM delivery d
JOIN first_order a
ON d.order_date = a.order_date and d.customer_id = a.customer_id

-- 550. Game Play Analysis IV
SELECT round(COUNT(DISTINCT b.player_id)/COUNT(DISTINCT a.player_id),2) as fraction
FROM (
    SELECT player_id, MIN(event_date) AS first_login 
    FROM activity 
    GROUP BY player_id
    ) a
LEFT JOIN activity b 
ON a.player_id = b.player_id AND DATEDIFF(a.first_login, b.event_date) = -1

-- 2356. Number of Unique Subjects Taught by Each Teacher
SELECT teacher_id, COUNT(DISTINCT subject_id) as cnt
FROM teacher
GROUP BY teacher_id

-- 1141. User Activity for the Past 30 Days I
SELECT activity_date as day, COUNT(DISTINCT user_id) as active_users
FROM activity
WHERE DATEDIFF('2019-07-27', activity_date) < 30 AND activity_date <= '2019-07-27'
GROUP BY activity_date

-- 1070. Product Sales Analysis III
SELECT a.product_id, a.first_year, b.quantity, b.price
FROM 
(SELECT product_id, min(year) AS first_year FROM sales GROUP BY product_id) a
JOIN sales b
ON a.product_id = b.product_id AND a.first_year = b.year

-- 596. Classes With at Least 5 Students
SELECT class
FROM courses
GROUP BY class
HAVING COUNT(student) >= 5

-- 1729. Find Followers Count
SELECT user_id, COUNT(follower_id) as followers_count
FROM followers
GROUP BY user_id
ORDER BY user_id ASC

-- 619. Biggest Single Number
SELECT MAX(a.num) as num
FROM (SELECT num
FROM MyNumbers
GROUP BY num
HAVING COUNT(num) = 1) a

-- 1045. Customers Who Bought All Products
SELECT customer_id
FROM customer 
GROUP BY customer_id
HAVING COUNT(DISTINCT product_key) = (SELECT COUNT(*) FROM product)

-- 1731. The Number of Employees Which Report to Each Employee
SELECT 
    b.employee_id, 
    b.name, 
    COUNT(a.employee_id) as reports_count, 
    ROUND(AVG(a.age),0) as average_age
FROM Employees a
JOIN Employees b
ON a.reports_to = b.employee_id
GROUP BY b.employee_id
ORDER BY b.employee_id

-- 1789. Primary Department for Each Employee
SELECT employee_id, department_id
FROM employee
WHERE primary_flag = 'Y' OR  employee_id IN (SELECT employee_id FROM employee GROUP BY employee_id HAVING count(department_id) = 1)

-- 610. Triangle Judgement
SELECT 
x, y, z,
CASE 
    WHEN x + z > y AND x + y > z AND y+z > x THEN 'Yes' 
    ELSE 'No' 
    END AS triangle
FROM triangle

-- 180. Consecutive Numbers
SELECT DISTINCT a.num AS ConsecutiveNums
FROM logs a, logs b, logs c
WHERE a.num = b.num AND b.num = c.num AND a.id = b.id - 1 AND b.id = c.id-1

-- 1164. Product Price at a Given Date
WITH a AS (
    SELECT 
        product_id,
        new_price,
        change_date,
        ROW_NUMBER() OVER (PARTITION BY product_id ORDER BY change_date DESC) AS rn
    FROM products
    WHERE change_date <='2019-08-16'                                
)

SELECT b.product_id, COALESCE(a.new_price,10) as price
FROM (SELECT DISTINCT product_id FROM products) as b
LEFT JOIN a
ON b.product_id = a.product_id AND a.rn = 1

-- 1240. Last Person to Fit in the Bus
SELECT a.person_name
FROM
(SELECT 
person_name,
SUM(weight) OVER (ORDER BY turn ASC) as total_weight
FROM queue) as a
WHERE a.total_weight <= 1000
ORDER BY a.total_weight DESC
LIMIT 1

-- 1907. Count Salary Categories
SELECT a.category, a.accounts_count
FROM 
(
    SELECT 
    'Low Salary' AS category, 
    SUM(CASE WHEN income < 20000 THEN 1 ELSE 0 END) AS accounts_count  
    FROM accounts

    UNION

    SELECT 
    'Average Salary' AS category, 
    SUM(CASE WHEN income BETWEEN 20000 AND 50000 THEN 1 ELSE 0 END) AS accounts_count  
    FROM accounts

    UNION

    SELECT 
    'High Salary' AS category, 
    SUM(CASE WHEN income > 50000 THEN 1 ELSE 0 END) AS accounts_count  
    FROM accounts
) as a
ORDER BY a.accounts_count DESC

-- 1978. Employees Whose Manager Left the Company
SELECT employee_id
FROM employees
WHERE manager_id NOT IN (SELECT employee_id FROM employees) AND salary < 30000
ORDER BY employee_id

-- 626. Exchange Seats
SELECT 
    IF(id < (SELECT MAX(id) from seat),
    IF(id % 2 = 0,id-1,id+1),
    IF(id % 2 = 0, id-1, id)) as id,
    student
FROM seat
ORDER BY ID ASC

-- 1341. Movie Rating

#Solution 1
WITH a AS(
    SELECT mr.movie_id, mr.user_id, mr.rating, mr.created_at,mv.title,u.name
    FROM movierating mr
    LEFT JOIN movies mv
    ON mr.movie_id = mv.movie_id
    LEFT JOIN users u
    ON mr.user_id = u.user_id
)

(SELECT a.name as results
FROM a
GROUP BY a.user_id
ORDER BY COUNT(a.user_id) DESC, a.name ASC
LIMIT 1)

UNION ALL

(SELECT a.title as results
FROM a
WHERE a.created_at BETWEEN '2020-02-01' AND '2020-02-29'
GROUP BY a.movie_id
ORDER BY AVG(a.rating) DESC, a.title ASC
LIMIT 1)

#Solution 2
SELECT name as results FROM
(
    SELECT user_id, name, COUNT(*)
    FROM Users JOIN MovieRating USING(user_id)
    GROUP BY 1,2
    ORDER BY 3 DESC, 2 ASC
    LIMIT 1
) users

UNION ALL

SELECT title as results FROM
(SELECT movie_id, title, AVG(rating)
FROM movies JOIN MovieRating USING(movie_id)
WHERE created_at BETWEEN '2020-02-01' AND '2020-02-29'
##WHERE LEFT(created_at,7) = '2020-02'
##WHERE DATE_FORMAT(created_at, '%Y-%m') = '2020-02'
GROUP BY 1,2
ORDER BY 3 DESC, 2 ASC
LIMIT 1) movie

-- 1321. Restauran Growth
SELECT DISTINCT
    visited_on,
    SUM(amount) OVER(ORDER BY visited_on ASC RANGE BETWEEN INTERVAL 6 DAY PRECEDING AND CURRENT ROW) as amount,
    ROUND((SUM(amount) OVER(ORDER BY visited_on ASC RANGE BETWEEN INTERVAL 6 DAY PRECEDING AND CURRENT ROW)/7),2) as average_amount
FROM customer
LIMIT 100000000 OFFSET 6

-- 602. Friend Request II: Who Has the Most Friends
SELECT id, num
FROM(
SELECT id, SUM(num) as num
FROM(
(SELECT requester_id AS id, COUNT(requester_id) AS num
FROM RequestAccepted
GROUP BY requester_id)

UNION ALL

(SELECT accepter_id AS id, COUNT(accepter_id) AS num
FROM RequestAccepted
GROUP BY accepter_id)
) b
GROUP BY id
) c
ORDER BY num DESC
LIMIT 1

#Solution 2
SELECT id, COUNT(id) as num
FROM 
(
    SELECT requester_id as id FROM RequestAccepted
    UNION ALL
    SELECT accepter_id as id FROM RequestAccepted
) a
GROUP BY id
ORDER BY num DESC
LIMIT 1

-- 585. Investments in 2016
SELECT ROUND(SUM(tiv_2016),2) as tiv_2016
FROM Insurance
WHERE tiv_2015 IN 
(SELECT tiv_2015 FROM Insurance GROUP BY tiv_2015 HAVING COUNT(*) > 1)
AND (lat, lon) IN (SELECT lat, lon FROM Insurance GROUP BY lat,lon HAVING COUNT(*) = 1)

-- 185. Department Top Three Salaries
SELECT department, employee, salary
FROM (
SELECT 
    d.name as department,
    e.name as employee,
    e.salary,
    DENSE_RANK() OVER (PARTITION BY d.name ORDER BY e.salary DESC) AS salary_rank
FROM employee e
JOIN department d
ON e.departmentId = d.id
) b
WHERE salary_rank <= 3
ORDER BY department ASC

-- 1667. Fix Names in The Table
#Solution 1
SELECT user_id, CONCAT(UPPER(LEFT(name,1)),LOWER(RIGHT(name, LENGTH(Name)-1))) as name
FROM users
ORDER BY user_id

#Solution 2
SELECT user_id, CONCAT(UPPER(SUBSTR(name,1,1)),LOWER(SUBSTR(name,2))) AS name
FROM users
ORDER BY user_id

-- 1327. List the Products Ordered in a Period
WITH a AS(
    SELECT product_id, SUM(unit) as unit
    FROM orders
    WHERE LEFT(order_date,7) = '2020-02'
    GROUP BY product_id
)

SELECT p.product_name, a.unit
FROM products p
LEFT JOIN a USING(product_id)
WHERE a.unit >= 100

-- 1527. Patients With a Condition
SELECT *
FROM Patients
WHERE conditions LIKE 'DIAB1%' or conditions LIKE '% DIAB1%'

-- 196. Delete Duplicate Emails
DELETE p2
FROM person p1 JOIN person p2
ON p1.email = p2.email AND p1.id < p2.id

-- 176. Second Highest Salary
SELECT
    (
        SELECT DISTINCT salary as SecondHighestSalary
        FROM(
                SELECT
                salary,
                DENSE_RANK() OVER(ORDER BY salary DESC) AS r
                FROM employee ) b
        WHERE r = 2) SecondHighestSalary

-- 1484. Group Sold Products By the Date
SELECT 
    sell_date, 
    COUNT(DISTINCT product) AS num_sold,
    GROUP_CONCAT(DISTINCT product ORDER BY product SEPARATOR ',') AS products
FROM activities
GROUP BY sell_date
ORDER BY sell_date

-- 1327. List the Product Ordered in a Period
WITH a AS(
    SELECT product_id, SUM(unit) as unit
    FROM orders
    WHERE LEFT(order_date,7) = '2020-02'
    GROUP BY product_id
)

SELECT p.product_name, a.unit
FROM products p
LEFT JOIN a USING(product_id)
WHERE a.unit >= 100

-- 1517. Find Users With Valid Emails
SELECT *
FROM users
WHERE REGEXP_LIKE(mail, '^[a-zA-Z][a-zA-Z0-9_.-]*@leetcode[.]com$','c')
-- ^ : Start of the string
-- * : 0 or more rept
-- \\ or [] : make sure . is treated as literal text
-- $ : ensure no str followed

-- 1179. Reformat Department Table
SELECT id,
SUM(IF(month = 'Jan',revenue,NULL)) AS Jan_Revenue,
SUM(IF(month = 'Feb',revenue,NULL)) AS Feb_Revenue,
SUM(IF(month = 'Mar',revenue,NULL)) AS Mar_Revenue,
SUM(IF(month = 'Apr',revenue,NULL)) AS Apr_Revenue,
SUM(IF(month = 'May',revenue,NULL)) AS May_Revenue,
SUM(IF(month = 'Jun',revenue,NULL)) AS Jun_Revenue,
SUM(IF(month = 'Jul',revenue,NULL)) AS Jul_Revenue,
SUM(IF(month = 'Aug',revenue,NULL)) AS Aug_Revenue,
SUM(IF(month = 'Sep',revenue,NULL)) AS Sep_Revenue,
SUM(IF(month = 'Oct',revenue,NULL)) AS Oct_Revenue,
SUM(IF(month = 'Nov',revenue,NULL)) AS Nov_Revenue,
SUM(IF(month = 'Dec',revenue,NULL)) AS Dec_Revenue
FROM department
GROUP BY id

-- 601. Human Traffic of Stadium
# Write your MySQL query statement below
WITH full_results AS (
    SELECT 
        id,
        visit_date,
        people,
        LEAD(people) OVER(ORDER BY id) AS next_day_people,
        LEAD(people, 2) OVER(ORDER BY id) AS next_two_day_people,
        LAG(people) OVER(ORDER BY id) AS prev_day_people,
        LAG(people, 2) OVER(ORDER BY id) AS prev_two_day_people
)

, id_selection AS (
    SELECT
        id,
        visit_date,
        people
    FROM full_results
    WHERE (people > 99 AND next_day_people > 99 AND next_two_day_people > 99) OR 
    (people > 99 AND prev_day_people > 99 AND prev_two_day_people > 99) OR
    (people > 99 AND next_day_people > 99 AND prev_day_people > 99)
)

SELECT *
FROM id_selection

-- 608. Tree Node 
SELECT 
    id,
    CASE 
        WHEN p_id IS NULL THEN "Root"
        WHEN id IN (SELECT DISTINCT p_id FROM Tree WHERE p_id IS NOT NULL) THEN "Inner"
        ELSE "Leaf"
    END AS type
FROM tree

-- 3793. Find Users with High Token Usage
SELECT user_id, COUNT(prompt) AS prompt_count, ROUND(AVG(tokens),2) AS avg_tokens
FROM prompts
GROUP BY user_id
HAVING prompt_count>2 AND MAX(tokens) > avg_tokens
ORDER BY avg_tokens DESC, user_id ASC

-- 3570. Find Books with No Available Copies
WITH a AS (
    SELECT book_id, COUNT(book_id) as borrowed
    FROM borrowing_records
    WHERE return_date IS NULL
    GROUP BY book_id
)

SELECT
    book_id,
    title,
    author,
    genre,
    publication_year,
    total_copies AS current_borrowers
FROM library_books l
JOIN a USING(book_id)
WHERE a.borrowed = l.total_copies
ORDER BY current_borrowers DESC, title ASC

-- 3465. Find Product with Valid Serial Numbers
SELECT *
FROM products
WHERE description REGEXP '(?-i)\\bSN[0-9]{4}\-[0-9]{4}\\b'
ORDER BY product_id ASC

##(?-i) ensure case sensitivity
##\b set word boundaries

-- 3220. Odd and Even Transactions
SELECT 
    transaction_date,
    SUM(CASE WHEN amount % 2 <> 0 THEN amount ELSE 0 END) as odd_sum,
    SUM(CASE WHEN amount % 2 = 0 THEN amount ELSE 0 END) as even_sum
FROM transactions
GROUP BY transaction_date
ORDER BY transaction_date ASC

-- 3421. Find Students Who Improved
WITH ranked AS (
    SELECT
        student_id,
        subject,
        FIRST_VALUE(score) OVER (PARTITION BY student_id, subject ORDER BY exam_date) as first_score,
        FIRST_VALUE(score) OVER (PARTITION BY student_id, subject ORDER BY exam_date DESC) as latest_score
    FROM scores
)

SELECT DISTINCT *
FROM ranked
WHERE first_score < latest_score
ORDER BY student_id ASC, subject ASC

-- 3475. DNA Pattern Recognition
SELECT
    sample_id,
    dna_sequence,
    species,
    CASE WHEN dna_sequence LIKE 'ATG%' THEN 1 ELSE 0 END AS has_start,
    CASE WHEN dna_sequence LIKE '%TAA' OR dna_sequence LIKE '%TAG' OR dna_sequence LIKE '%TGA' THEN 1 ELSE 0 END AS has_stop,
    CASE WHEN dna_sequence LIKE '%ATAT%' THEN 1 ELSE 0 END AS has_atat,
    CASE WHEN dna_sequence LIKE '%GGG%' THEN 1 ELSE 0 END AS has_ggg
FROM samples
ORDER BY sample_id

-- 3497. Analyze Subscription Conversion
SELECT 
    user_id,
    ROUND(AVG(CASE WHEN activity_type = 'free_trial' THEN activity_duration ELSE NULL END),2) AS trial_avg_duration,
    ROUND(AVG(CASE WHEN activity_type = 'paid' THEN activity_duration ELSE NULL END),2) AS paid_avg_duration
FROM UserActivity
GROUP BY user_id
HAVING paid_avg_duration > 0
ORDER BY user_id ASC

-- 3521 - Find Product Recommendation Pairs
SELECT 
    p1.product_id as product1_id,
    p2.product_id as product2_id,
    pin.category as product1_category,
    pin2.category as product2_category,
    COUNT(user_id) as customer_count
FROM ProductPurchases p1
INNER JOIN ProductPurchases p2 USING(user_id)
JOIN ProductInfo pin
ON p1.product_id = pin.product_id
JOIN ProductInfo pin2
ON p2.product_id = pin2.product_id
WHERE p1.product_id < p2.product_id
GROUP BY p1.product_id, p2.product_id
HAVING customer_count > 2
ORDER BY customer_count DESC, product1_id ASC, product2_id ASC

-- 3580. Find Consistently Improving Employees
WITH a AS(
    SELECT 
        employee_id,
        rating,
        RANK() OVER (PARTITION BY employee_id ORDER BY review_date DESC) as ranking
    FROM performance_reviews
),
b AS(
SELECT
    employee_id,
    SUM(CASE WHEN ranking = 1 THEN rating END) AS r1,
    SUM(CASE WHEN ranking = 2 THEN rating END) AS r2,
    SUM(CASE WHEN ranking = 3 THEN rating END) AS r3
FROM a
WHERE ranking < 4
GROUP BY employee_id
)

SELECT 
    employee_id,
    name,
    r1-r3 AS improvement_score
FROM b
LEFT JOIN employees USING(employee_id)
WHERE b.r1 IS NOT NULL AND b.r2 IS NOT NULL AND b.r3 IS NOT NULL AND b.r1 > b.r2  AND b.r2 > b.r3 
ORDER BY improvement_score DESC, name ASC

-- 3586. Find Covid Recovery Patients
SELECT 
    c1.patient_id,
    p.patient_name,
    p.age, 
    DATEDIFF(MIN(c2.test_date),MIN(c1.test_date)) as recovery_time
FROM covid_tests c1
JOIN covid_tests c2 USING(patient_id)
JOIN patients p ON c1.patient_id = p.patient_id
WHERE (c1.test_date < c2.test_date) AND (c1.result = 'Positive') AND (c2.result = 'Negative')
GROUP BY patient_id 
ORDER BY recovery_time ASC, p.patient_name ASC

--3601. Find Drivers with Improved Fuel Efficiency
WITH d AS
(
SELECT 
    driver_id,
    driver_name,
    AVG(CASE WHEN period = 'first' THEN eff ELSE NULL END) AS first_half_avg,
    AVG(CASE WHEN period = 'second' THEN eff ELSE NULL END) AS second_half_avg
FROM
(SELECT *, CASE WHEN MONTH(trip_date) < 7 THEN 'first' ELSE 'second' END AS period, distance_km/fuel_consumed AS eff 
FROM trips
JOIN drivers USING(driver_id)) as t
GROUP BY driver_id
)

SELECT
    driver_id,
    driver_name,
    ROUND(first_half_avg,2) AS first_half_avg,
    ROUND(second_half_avg,2) AS second_half_avg,
    ROUND(second_half_avg - first_half_avg,2) AS efficiency_improvement
FROM d
WHERE first_half_avg IS NOT NULL AND second_half_avg IS NOT NULL AND first_half_avg < second_half_avg
ORDER BY efficiency_improvement DESC, driver_name ASC

-- 3611. Find Overbooked Employees
WITH a AS(
    SELECT *, WEEK(meeting_date, 3) as week_num
    FROM meetings
),
b AS (
    SELECT employee_id, week_num, SUM(duration_hours) as hours
    FROM a
    GROUP BY employee_id, week_num
    HAVING hours > 20
)

SELECT b.employee_id, e.employee_name, e.department, COUNT(*) as meeting_heavy_weeks
FROM b
JOIN employees e USING(employee_id)
GROUP BY b.employee_id
HAVING meeting_heavy_weeks > 1
ORDER BY meeting_heavy_weeks DESC, employee_name ASC

-- 3626. Find Stores with Inventory Imbalance
WITH value AS (
    SELECT store_id, MAX(price) as max_price, MIN(price) as min_price
    FROM inventory
    GROUP BY store_id
    HAVING COUNT(store_id)>2
),
value2 AS(
    SELECT 
        v.store_id,
        MAX(CASE WHEN i.price = v.max_price THEN i.product_name END) AS most_exp_product,
        MAX(CASE WHEN i.price = v.min_price THEN i.product_name END) AS cheapest_product,
        MAX(CASE WHEN i.price = v.max_price THEN i.quantity END) AS most_exp_quantity,
        MAX(CASE WHEN i.price = v.min_price THEN i.quantity END) AS cheapest_quantity
    FROM value v
    JOIN inventory i USING(store_id)
    GROUP BY v.store_id
    HAVING most_exp_quantity < cheapest_quantity
)

#FROM inventory i JOIN value v ON i.store_id = v.store_id AND (i.price = v.max_price OR i.price = v.min_price)

SELECT 
    store_id,
    s.store_name,
    s.location,
    v2.most_exp_product,
    v2.cheapest_product,
    ROUND(v2.cheapest_quantity/v2.most_exp_quantity,2) AS imbalance_ratio
FROM value2 v2
JOIN stores s USING(store_id)
ORDER BY imbalance_ratio DESC, store_name ASC

-- 3642. Find Books with Polarized Opinions
WITH CTE AS(
SELECT 
    book_id, 
    MAX(session_rating) AS maxv, 
    MIN(session_rating) AS minv, 
    COUNT('session_id') AS sessions,
    SUM(CASE WHEN session_rating <> 3 THEN 1 ELSE 0 END) AS countx
FROM reading_sessions
GROUP BY book_id
HAVING sessions >= 5 AND maxv >=4 AND minv <=2
)

SELECT c.book_id, b.title, b.author, b.genre, b.pages, (c.maxv - minv) AS rating_spread, ROUND(c.countx/c.sessions,2) AS polarization_score 
FROM CTE c
JOIN books b USING(book_id)
GROUP BY c.book_id
HAVING polarization_score >= 0.6
ORDER BY polarization_score DESC, title DESC

-- 3657. Find Loyal Customers
SELECT customer_id
FROM customer_transactions
GROUP BY customer_id
HAVING
    COUNT(customer_id) > 2 AND
    DATEDIFF(MAX(transaction_date),MIN(transaction_date)) >= 30 AND
    (SUM(CASE WHEN transaction_type = "refund" THEN 1 ELSE 0 END)/COUNT(customer_id)) < 0.2
ORDER BY customer_id ASC

-- 3705. Find Golden Hour Customers
SELECT
    customer_id,
    COUNT(customer_id) AS total_orders,
    ROUND(SUM(CASE WHEN TIME(order_timestamp) BETWEEN TIME('11:00:00') AND TIME('14:00:00') OR TIME(order_timestamp) BETWEEN TIME('18:00:00') AND TIME('21:00:00') THEN 1 ELSE 0 END) /  COUNT('customer_id')*100,0) AS peak_hour_percentage,
    ROUND(AVG(order_rating),2) AS average_rating
FROM restaurant_orders 
GROUP BY customer_id
HAVING 
    COUNT('customer_id') >= 3 AND
    SUM(CASE WHEN TIME(order_timestamp) BETWEEN TIME('11:00:00') AND TIME('14:00:00') OR TIME(order_timestamp) BETWEEN TIME('18:00:00') AND TIME('21:00:00') THEN 1 ELSE 0 END) /  COUNT('customer_id') >0.6 AND
    ROUND(AVG(order_rating),2) >= 4 AND
    SUM(CASE WHEN order_rating IS NOT NULL THEN 1 ELSE 0 END) / COUNT('customer_id') >= 0.5
ORDER BY average_rating DESC, customer_id DESC

-- 3716. Find Churn Risk Customers
WITH plan AS (
    SELECT 
        *,
        ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY event_date DESC) AS event 
    FROM subscription_events
),
plan2 AS(
    SELECT 
        user_id,
        MAX(CASE WHEN event = 1 THEN plan_name END) AS current_plan,
        MAX(CASE WHEN event = 1 THEN monthly_amount END) AS current_monthly_amount,
        MAX(monthly_amount) AS max_historical_amount,
        DATEDIFF(MAX(event_date), MIN(event_date)) AS days_as_subscriber
    FROM plan
    GROUP BY user_id
)

SELECT *
FROM plan2
WHERE 
    current_plan IS NOT NULL AND
    current_monthly_amount/max_historical_amount < 0.5 AND
    days_as_subscriber >= 60
ORDER BY days_as_subscriber DESC, user_id ASC
